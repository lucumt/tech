<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç½‘ç»œ on ä¸ªäººç¬”è®°</title>
    <link>https://tech.lucumt.info/docs/network/</link>
    <description>Recent content in ç½‘ç»œ on ä¸ªäººç¬”è®°</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://tech.lucumt.info/docs/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ç½‘ç»œ7å±‚æ¨¡å‹</title>
      <link>https://tech.lucumt.info/docs/network/what-is-osi-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/what-is-osi-model/</guid>
      <description>How is data sent over the network? Why do we need so many layers in the OSI model?&#xA;The diagram below shows how data is encapsulated and de-encapsulated when transmitting over the network.&#xA;ğŸ”¹ Step 1: When Device A sends data to Device B over the network via the HTTP protocol, it is first added an HTTP header at the application layer.&#xA;ğŸ”¹ Step 2: Then a TCP or a UDP header is added to the data.</description>
    </item>
    <item>
      <title>8ç§ä¸»è¦çš„ç½‘ç»œåè®®</title>
      <link>https://tech.lucumt.info/docs/network/8-popular-network-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/8-popular-network-protocols/</guid>
      <description></description>
    </item>
    <item>
      <title>TCPçŠ¶æ€å˜åŒ–å›¾</title>
      <link>https://tech.lucumt.info/docs/network/tcp-status-change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/tcp-status-change/</guid>
      <description></description>
    </item>
    <item>
      <title>HTTPçŠ¶æ€ç è¯´æ˜</title>
      <link>https://tech.lucumt.info/docs/network/http-status/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/http-status/</guid>
      <description></description>
    </item>
    <item>
      <title>ç½‘ç»œåè®®ä¾èµ–</title>
      <link>https://tech.lucumt.info/docs/network/network-protocol-dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/network-protocol-dependencies/</guid>
      <description>Must-Know Network Protocol Dependencies&#xA;Understanding network protocol dependencies is essential for cybersecurity and networking. Hereâ€™s a quick understanding of the same:&#xA;IPv4 and IPv6 are the foundation of all networking. ICMP and ICMPv6 handle diagnostics, while IPsec ensures secure communication. TCP and UDP support various protocols. SCTP and DCCP serve specific cases. Some TCP-based protocols are HTTP, SSH, BGP, RDP, IMAP, SMTP, POP, etc. UDP-based protocols are DNS, DHCP, SIP, RTP, NTP, etc.</description>
    </item>
    <item>
      <title>æµè§ˆå™¨å¦‚ä½•å¤„ç†ç½‘ç»œè¯·æ±‚</title>
      <link>https://tech.lucumt.info/docs/network/what-happens-when-type-url-in-browser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/what-happens-when-type-url-in-browser/</guid>
      <description>What happens when you type a URL into a browser?&#xA;Letâ€™s look at the process step by step.&#xA;Step 1: The user enters a URL (bytebytego .com) into the browser and hits Enter. The first thing we need to do is to translate the URL to an IP address. The mapping is usually stored in a cache, so the browser looks for the IP address in multiple layers of cache: the browser cache, OS cache, local cache, and ISP cache.</description>
    </item>
    <item>
      <title>Nginxå¼ºå¤§çš„åŸå› </title>
      <link>https://tech.lucumt.info/docs/network/what-makes-nginx-so-useful/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/network/what-makes-nginx-so-useful/</guid>
      <description>&#xA;What Makes Nginx So Useful&#xA;Core Architecture: Master-worker process model handles connections efficiently High-Performance: Server Handles thousands of concurrent connections effortlessly Reverse Proxy: Distributes traffic across multiple backend servers Features: Built-in caching and SSL handling for speed and security </description>
    </item>
  </channel>
</rss>
