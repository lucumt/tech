<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç†è®º on ä¸ªäººç¬”è®°</title>
    <link>https://tech.lucumt.info/docs/code/theory/</link>
    <description>Recent content in ç†è®º on ä¸ªäººç¬”è®°</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://tech.lucumt.info/docs/code/theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ä¸åŒè¯­è¨€çš„å·¥ä½œåŸç†</title>
      <link>https://tech.lucumt.info/docs/code/theory/language-compare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/language-compare/</guid>
      <description>How Do C++, Java, Python Work?&#xA;The diagram shows how the compilation and execution work.&#xA;Compiled languages are compiled into machine code by the compiler. The machine code can later be executed directly by the CPU. Examples: C, C++, Go.&#xA;A bytecode language like Java, compiles the source code into bytecode first, then the JVM executes the program. Sometimes JIT (Just-In-Time) compiler compiles the source code into machine code to speed up the execution.</description>
    </item>
    <item>
      <title>å¹¶å‘ä¸æ˜¯å¹¶è¡Œ</title>
      <link>https://tech.lucumt.info/docs/code/theory/concurrency-is-not-parallelism/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/concurrency-is-not-parallelism/</guid>
      <description>Things Every Developer Should Know: Concurrency is ğğğ“ parallelism.&#xA;In system design, it is important to understand the difference between concurrency and parallelism.&#xA;As Rob Pyke(one of the creators of GoLang) stated:â€œ Concurrency is about ğğğšğ¥ğ¢ğ§ğ  ğ°ğ¢ğ­ğ¡ lots of things at once. Parallelism is about ğğ¨ğ¢ğ§ğ  lots of things at once.&amp;quot; This distinction emphasizes that concurrency is more about the ğğğ¬ğ¢ğ ğ§ of a program, while parallelism is about the ğğ±ğğœğ®ğ­ğ¢ğ¨ğ§.</description>
    </item>
    <item>
      <title>ç¼–å†™å‡ºå®‰å…¨æœ‰æ•ˆçš„API</title>
      <link>https://tech.lucumt.info/docs/code/theory/design-effective-and-safe-apis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/design-effective-and-safe-apis/</guid>
      <description>Note that API design is not just URL path design. Most of the time, we need to choose the proper resource names, identifiers, and path patterns. It is equally important to design proper HTTP header fields or to design effective rate-limiting rules within the API gateway.</description>
    </item>
    <item>
      <title>REST API vs GraphQL</title>
      <link>https://tech.lucumt.info/docs/code/theory/top-9-system-integrations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/top-9-system-integrations/</guid>
      <description>REST API Vs. GraphQL When it comes to API design, REST and GraphQL each have their own strengths and weaknesses.&#xA;REST - Uses standard HTTP methods like GET, POST, PUT, DELETE for CRUD operations. - Works well when you need simple, uniform interfaces between separate services/applications. - Caching strategies are straightforward to implement. - The downside is it may require multiple roundtrips to assemble related data from separate endpoints.</description>
    </item>
    <item>
      <title>æ•°æ®é€šä¿¡çš„9ç§æ¶æ„æ¨¡å¼</title>
      <link>https://tech.lucumt.info/docs/code/theory/rest-api-vs-graphql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/rest-api-vs-graphql/</guid>
      <description>Top 9 Architectural Patterns for Data and Communication Flow&#xA;ğŸ”¹ Peer-to-Peer The Peer-to-Peer pattern involves direct communication between two components without the need for a central coordinator.&#xA;ğŸ”¹ API Gateway An API Gateway acts as a single entry point for all client requests to the backend services of an application.&#xA;ğŸ”¹ Pub-Sub The Pub-Sub pattern decouples the producers of messages (publishers) from the consumers of messages (subscribers) through a message broker.</description>
    </item>
    <item>
      <title>è½¯ä»¶å¼€å‘12å‡†åˆ™</title>
      <link>https://tech.lucumt.info/docs/code/theory/12-factor-app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/12-factor-app/</guid>
      <description>Have you heard of the 12-Factor App?&#xA;The &amp;ldquo;12 Factor App&amp;rdquo; offers a set of best practices for building modern software applications. Following these 12 principles can help developers and teams in building reliable, scalable, and manageable applications.&#xA;Here&amp;rsquo;s a brief overview of each principle:&#xA;Codebase: Have one place to keep all your code, and manage it using version control like Git.&#xA;Dependencies: List all the things your app needs to work properly, and make sure they&amp;rsquo;re easy to install.</description>
    </item>
    <item>
      <title>10ä¸ªè‰¯å¥½ç¼–ç å‡†åˆ™</title>
      <link>https://tech.lucumt.info/docs/code/theory/10-good-coding-principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/10-good-coding-principle/</guid>
      <description>Software development requires good system designs and coding standards. We list 10 good coding principles in the diagram below.&#xA;ğŸ”¹ 01 Follow Code Specifications When we write code, it is important to follow the industry&amp;rsquo;s well-established norms, like â€œPEP 8â€, â€œGoogle Java Styleâ€, adhering to a set of agreed-upon code specifications ensures that the quality of the code is consistent and readable.&#xA;ğŸ”¹ 02 Documentation and Comments Good code should be clearly documented and commented to explain complex logic and decisions, and comments should explain why a certain approach was taken (â€œWhyâ€) rather than what exactly is being done (â€œWhatâ€).</description>
    </item>
    <item>
      <title>ç³»ç»Ÿè®¾è®¡çš„15ä¸ªæ ¸å¿ƒæ¦‚å¿µ</title>
      <link>https://tech.lucumt.info/docs/code/theory/15-system-design-core-concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/15-system-design-core-concepts/</guid>
      <description></description>
    </item>
    <item>
      <title>ç¼–ç /åŠ å¯†/åˆ†è¯</title>
      <link>https://tech.lucumt.info/docs/code/theory/encoding-vs-encryption-vs-tokenization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/code/theory/encoding-vs-encryption-vs-tokenization/</guid>
      <description>Encoding vs Encryption vs Tokenization. Encoding, encryption, and tokenization are three distinct processes that handle data in different ways for various purposes, including data transmission, security, and compliance. In system designs, we need to select the right approach for handling sensitive information.&#xA;ğŸ”¹ Encoding Encoding converts data into a different format using a scheme that can be easily reversed. Examples include Base64 encoding, which encodes binary data into ASCII characters, making it easier to transmit data over media that are designed to deal with textual data.</description>
    </item>
  </channel>
</rss>
