<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>理论 on 个人笔记</title>
    <link>https://tech.lucumt.info/docs/db/theory/</link>
    <description>Recent content in 理论 on 个人笔记</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://tech.lucumt.info/docs/db/theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>8个关键数据结构</title>
      <link>https://tech.lucumt.info/docs/db/theory/8-key-data-structures-that-power-modern-databases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/8-key-data-structures-that-power-modern-databases/</guid>
      <description>&#xA;8 Key Data Structures That Power Modern Databases&#xA;Skiplist: a common in-memory index type. Used in Redis Hash index: a very common implementation of the “Map” data structure (or “Collection”) SSTable: immutable on-disk “Map” implementation LSM tree: Skiplist + SSTable. High write throughput B-tree: disk-based solution. Consistent read/write performance Inverted index: used for document indexing. Used in Lucene Suffix tree: for string pattern search R-tree: multi-dimension search, such as finding the nearest neighbor </description>
    </item>
    <item>
      <title>搜索引擎如何工作</title>
      <link>https://tech.lucumt.info/docs/db/theory/how-does-search-engine-work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/how-does-search-engine-work/</guid>
      <description>The diagram below shows a high-level walk-through of a search engine.&#xA;▶️ Step 1 - Crawling Web Crawlers scan the internet for web pages. They follow the URL links from one page to another and store URLs in the URL store. The crawlers discover new content, including web pages, images, videos, and files.&#xA;▶️ Step 2 - Indexing Once a web page is crawled, the search engine parses the page and indexes the content found on the page in a database.</description>
    </item>
    <item>
      <title>6种数据管理模式</title>
      <link>https://tech.lucumt.info/docs/db/theory/top-6-data-manage-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/top-6-data-manage-patterns/</guid>
      <description>How do we manage data? Here are top 6 data management patterns.&#xA;🔹 Cache Aside When an application needs to access data, it first checks the cache. If the data is not present (a cache miss), it fetches the data from the data store, stores it in the cache, and then returns the data to the user. This pattern is particularly useful for scenarios where data is read frequently but updated less often.</description>
    </item>
    <item>
      <title>6种数据模型</title>
      <link>https://tech.lucumt.info/docs/db/theory/top-6-database-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/top-6-database-models/</guid>
      <description>The diagram below shows top 6 data models.&#xA;🔹 Flat Model The flat data model is one of the simplest forms of database models. It organizes data into a single table where each row represents a record and each column represents an attribute. This model is similar to a spreadsheet and is straightforward to understand and implement. However, it lacks the ability to efficiently handle complex relationships between data entities.</description>
    </item>
    <item>
      <title>选择合适的数据库</title>
      <link>https://tech.lucumt.info/docs/db/theory/choosing-the-right-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/choosing-the-right-database/</guid>
      <description>Choosing the Right Database&#xA;When deciding which type of database to use, it can be overwhelming to choose from the many available options. Here&amp;rsquo;s a brief summary of some common database architectures and their use cases:&#xA;Relational databases: These are versatile and can solve almost any problem. They are suitable for structured data with well-defined relationships between entities.&#xA;In-memory stores: With their high speed and limited data size, in-memory databases are perfect for applications that require fast operations, such as caching or real-time analytics.</description>
    </item>
    <item>
      <title>扩展数据库的7种策略</title>
      <link>https://tech.lucumt.info/docs/db/theory/database-scaling-cheatsheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/database-scaling-cheatsheet/</guid>
      <description>7 must-know strategies to scale your database.&#xA;1 - Indexing: Check the query patterns of your application and create the right indexes.&#xA;2 - Materialized Views: Pre-compute complex query results and store them for faster access.&#xA;3 - Denormalization: Reduce complex joins to improve query performance.&#xA;4 - Vertical Scaling Boost your database server by adding more CPU, RAM, or storage.&#xA;5 - Caching Store frequently accessed data in a faster storage layer to reduce database load.</description>
    </item>
    <item>
      <title>SQL查询执行顺序</title>
      <link>https://tech.lucumt.info/docs/db/theory/sql-query-logical-order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/sql-query-logical-order/</guid>
      <description>SQL statements are executed by the database system in several steps, including: - Parsing the SQL statement and checking its validity - Transforming the SQL into an internal representation, such as relational algebra - Optimizing the internal representation and creating an execution plan that utilizes index information - Executing the plan and returning the results</description>
    </item>
  </channel>
</rss>
