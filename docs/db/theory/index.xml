<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç†è®º on ä¸ªäººç¬”è®°</title>
    <link>https://tech.lucumt.info/docs/db/theory/</link>
    <description>Recent content in ç†è®º on ä¸ªäººç¬”è®°</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://tech.lucumt.info/docs/db/theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>æ•°æ®åº“ä¸­çš„8ä¸ªå…³é”®æ•°æ®ç»“æ„</title>
      <link>https://tech.lucumt.info/docs/db/theory/8-key-data-structures-that-power-modern-databases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/8-key-data-structures-that-power-modern-databases/</guid>
      <description>8 Key Data Structures That Power Modern Databases ğŸ”¹Skiplist: a common in-memory index type. Used in Redis ğŸ”¹Hash index: a very common implementation of the â€œMapâ€ data structure (or â€œCollectionâ€) ğŸ”¹SSTable: immutable on-disk â€œMapâ€ implementation ğŸ”¹LSM tree: Skiplist + SSTable. High write throughput ğŸ”¹B-tree: disk-based solution. Consistent read/write performance ğŸ”¹Inverted index: used for document indexing. Used in Lucene ğŸ”¹Suffix tree: for string pattern search ğŸ”¹R-tree: multi-dimension search, such as finding the nearest neighbor</description>
    </item>
    <item>
      <title>æœç´¢å¼•æ“å¦‚ä½•å·¥ä½œ</title>
      <link>https://tech.lucumt.info/docs/db/theory/how-does-search-engine-work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/how-does-search-engine-work/</guid>
      <description>The diagram below shows a high-level walk-through of a search engine.&#xA;â–¶ï¸ Step 1 - Crawling Web Crawlers scan the internet for web pages. They follow the URL links from one page to another and store URLs in the URL store. The crawlers discover new content, including web pages, images, videos, and files.&#xA;â–¶ï¸ Step 2 - Indexing Once a web page is crawled, the search engine parses the page and indexes the content found on the page in a database.</description>
    </item>
    <item>
      <title>6ç§æ•°æ®ç®¡ç†æ¨¡å¼</title>
      <link>https://tech.lucumt.info/docs/db/theory/top-6-data-manage-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/top-6-data-manage-patterns/</guid>
      <description>How do we manage data? Here are top 6 data management patterns.&#xA;ğŸ”¹ Cache Aside When an application needs to access data, it first checks the cache. If the data is not present (a cache miss), it fetches the data from the data store, stores it in the cache, and then returns the data to the user. This pattern is particularly useful for scenarios where data is read frequently but updated less often.</description>
    </item>
    <item>
      <title>6ç§æ•°æ®æ¨¡å‹</title>
      <link>https://tech.lucumt.info/docs/db/theory/top-6-database-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tech.lucumt.info/docs/db/theory/top-6-database-models/</guid>
      <description>The diagram below shows top 6 data models.&#xA;ğŸ”¹ Flat Model The flat data model is one of the simplest forms of database models. It organizes data into a single table where each row represents a record and each column represents an attribute. This model is similar to a spreadsheet and is straightforward to understand and implement. However, it lacks the ability to efficiently handle complex relationships between data entities.</description>
    </item>
  </channel>
</rss>
